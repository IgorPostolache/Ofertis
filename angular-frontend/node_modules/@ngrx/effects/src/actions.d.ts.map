{"version":3,"file":"actions.d.ts","sources":["actions.d.ts"],"names":[],"mappings":"AAAA;AACA;;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sourcesContent":["import { Action, ActionCreator, Creator } from '@ngrx/store';\nimport { Observable, OperatorFunction, Operator } from 'rxjs';\nexport declare class Actions<V = Action> extends Observable<V> {\n    constructor(source?: Observable<V>);\n    lift<R>(operator: Operator<V, R>): Observable<R>;\n}\ndeclare type ActionExtractor<T extends string | AC, AC extends ActionCreator<string, Creator>, E> = T extends string ? E : ReturnType<Extract<T, AC>>;\n/**\n * 'ofType' filters an Observable of Actions into an observable of the actions\n * whose type strings are passed to it.\n *\n * For example, if `actions` has type `Actions<AdditionAction|SubstractionAction>`, and\n * the type of the `Addition` action is `add`, then\n * `actions.pipe(ofType('add'))` returns an `Observable<AdditionAction>`.\n *\n * Properly typing this function is hard and requires some advanced TS tricks\n * below.\n *\n * Type narrowing automatically works, as long as your `actions` object\n * starts with a `Actions<SomeUnionOfActions>` instead of generic `Actions`.\n *\n * For backwards compatibility, when one passes a single type argument\n * `ofType<T>('something')` the result is an `Observable<T>`. Note, that `T`\n * completely overrides any possible inference from 'something'.\n *\n * Unfortunately, for unknown 'actions: Actions' these types will produce\n * 'Observable<never>'. In such cases one has to manually set the generic type\n * like `actions.ofType<AdditionAction>('add')`.\n */\nexport declare function ofType<AC extends ActionCreator<string, Creator>[], U extends Action = Action, V = ReturnType<AC[number]>>(...allowedTypes: AC): OperatorFunction<U, V>;\nexport declare function ofType<E extends Extract<U, {\n    type: T1;\n}>, AC extends ActionCreator<string, Creator>, T1 extends string | AC, U extends Action = Action, V = T1 extends string ? E : ReturnType<Extract<T1, AC>>>(t1: T1): OperatorFunction<U, V>;\nexport declare function ofType<E extends Extract<U, {\n    type: T1 | T2;\n}>, AC extends ActionCreator<string, Creator>, T1 extends string | AC, T2 extends string | AC, U extends Action = Action, V = ActionExtractor<T1 | T2, AC, E>>(t1: T1, t2: T2): OperatorFunction<U, V>;\nexport declare function ofType<E extends Extract<U, {\n    type: T1 | T2 | T3;\n}>, AC extends ActionCreator<string, Creator>, T1 extends string | AC, T2 extends string | AC, T3 extends string | AC, U extends Action = Action, V = ActionExtractor<T1 | T2 | T3, AC, E>>(t1: T1, t2: T2, t3: T3): OperatorFunction<U, V>;\nexport declare function ofType<E extends Extract<U, {\n    type: T1 | T2 | T3 | T4;\n}>, AC extends ActionCreator<string, Creator>, T1 extends string | AC, T2 extends string | AC, T3 extends string | AC, T4 extends string | AC, U extends Action = Action, V = ActionExtractor<T1 | T2 | T3 | T4, AC, E>>(t1: T1, t2: T2, t3: T3, t4: T4): OperatorFunction<U, V>;\nexport declare function ofType<E extends Extract<U, {\n    type: T1 | T2 | T3 | T4 | T5;\n}>, AC extends ActionCreator<string, Creator>, T1 extends string | AC, T2 extends string | AC, T3 extends string | AC, T4 extends string | AC, T5 extends string | AC, U extends Action = Action, V = ActionExtractor<T1 | T2 | T3 | T4 | T5, AC, E>>(t1: T1, t2: T2, t3: T3, t4: T4, t5: T5): OperatorFunction<U, V>;\n/**\n * Fallback for more than 5 arguments.\n * There is no inference, so the return type is the same as the input -\n * Observable<Action>.\n *\n * We provide a type parameter, even though TS will not infer it from the\n * arguments, to preserve backwards compatibility with old versions of ngrx.\n */\nexport declare function ofType<V extends Action>(...allowedTypes: Array<string | ActionCreator<string, Creator>>): OperatorFunction<Action, V>;\nexport {};\n"]}
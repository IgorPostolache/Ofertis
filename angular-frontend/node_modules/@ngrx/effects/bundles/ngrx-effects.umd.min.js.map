{"version":3,"sources":["../../../../modules/effects/src/models.ts","../../../../modules/effects/src/effect_creator.ts","../../../../modules/effects/src/utils.ts","../../../../modules/effects/src/effect_decorator.ts","../../../../modules/effects/src/effects_metadata.ts","../../../../node_modules/tslib/tslib.es6.js","../../../../modules/effects/src/effects_resolver.ts","../../../../modules/effects/src/effects_error_handler.ts","../../../../modules/effects/src/actions.ts","../../../../modules/effects/src/effect_notification.ts","../../../../modules/effects/src/lifecycle_hooks.ts","../../../../modules/effects/src/tokens.ts","../../../../modules/effects/src/effect_sources.ts","../../../../modules/effects/src/effects_runner.ts","../../../../modules/effects/src/effects_root_module.ts","../../../../modules/effects/src/effects_feature_module.ts","../../../../modules/effects/src/effects_module.ts","../../../../modules/effects/src/act.ts"],"names":["DEFAULT_EFFECT_CONFIG","dispatch","useEffectsErrorHandler","getCreateEffectMetadata","instance","Object","getOwnPropertyNames","filter","propertyName","hasOwnProperty","map","metaData","assign","getSourceForInstance","getPrototypeOf","getEffectDecoratorMetadata","compose","getEffectMetadataEntries","hasMetadataEntries","sourceProto","constructor","getSourceMetadata","reduce","sources","source","concat","extendStatics","d","b","setPrototypeOf","__proto__","Array","p","__extends","__","this","prototype","create","__values","o","s","Symbol","iterator","m","i","call","length","next","value","done","TypeError","__read","n","r","e","ar","push","error","__spread","arguments","mergeEffects","sourceInstance","globalErrorHandler","effectsErrorHandler","sourceName","name","observables$","_a","observable$","effectAction$","pipe","ignoreElements","materialize","notification","effect","merge","apply","defaultEffectsErrorHandler","errorHandler","retryAttemptLeft","catchError","handleError","Actions","_this","_super","lift","operator","observable","Observable","reportInvalidActions","output","reporter","kind","action","type","isAction","Error","_b","isMethod","String","JSON","stringify","Injectable","decorators","Inject","args","ScannedActionsSubject","isOnInitEffects","isFunction","functionName","_ROOT_EFFECTS_GUARD","InjectionToken","USER_PROVIDED_EFFECTS","_ROOT_EFFECTS","ROOT_EFFECTS","_FEATURE_EFFECTS","FEATURE_EFFECTS","EFFECTS_ERROR_HANDLER","EffectSources","addEffects","effectSourceInstance","toActions","groupBy","mergeMap","source$","effectsInstance","effect$","exhaustMap","mergedEffects$","ngrxOnRunEffects","dematerialize","init$","take","ngrxOnInitEffects","Subject","ngrxOnIdentifyEffects","ErrorHandler","EffectsRunner","effectSources","store","effectsSubscription","start","subscribe","ngOnDestroy","unsubscribe","Store","rootEffectsInit","createAction","EffectsRootModule","runner","rootEffects","storeRootModule","storeFeatureModule","guard","forEach","NgModule","StoreRootModule","Optional","StoreFeatureModule","root","effectSourceGroups","group","EffectsModule","forFeature","featureEffects","ngModule","EffectsFeatureModule","providers","provide","multi","useValue","useFactory","createEffects","deps","Injector","forRoot","_provideForRootGuard","SkipSelf","Self","injector","effectGroups","userProvidedEffectGroups","mergedEffects","effectGroups_1","effectGroups_1_1","effectGroup","userProvidedEffectGroups_1","userProvidedEffectGroups_1_1","userProvidedEffectGroup","effects","get","createEffectInstances","config","target","metadata","defineProperty","addEffectMetadataEntry","configOrProject","errorFn","project","concatMap","complete","undefined","defer","subject","input","index","completed","errored","projectedCount","Notification","finalize","acc","allowedTypes","_i","some","typeOrActionCreator"],"mappings":"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","sourcesContent":["/**\n * Configures an effect created by `createEffect`.\n */\nexport interface EffectConfig {\n  /**\n   * Determines if the action emitted by the effect is dispatched to the store.\n   * If false, effect does not need to return type `Observable<Action>`.\n   */\n  dispatch?: boolean;\n  /**\n   * Determines if the effect will be resubscribed to if an error occurs in the main actions stream.\n   */\n  useEffectsErrorHandler?: boolean;\n}\n\nexport const DEFAULT_EFFECT_CONFIG: Readonly<Required<EffectConfig>> = {\n  dispatch: true,\n  useEffectsErrorHandler: true,\n};\n\nexport const CREATE_EFFECT_METADATA_KEY = '__@ngrx/effects_create__';\n\nexport interface CreateEffectMetadata {\n  [CREATE_EFFECT_METADATA_KEY]: EffectConfig;\n}\n\nexport type EffectPropertyKey<T extends Object> = Exclude<\n  keyof T,\n  keyof Object\n>;\n\nexport interface EffectMetadata<T extends Object>\n  extends Required<EffectConfig> {\n  propertyName: EffectPropertyKey<T>;\n}\n\nexport type EffectsMetadata<T> = {\n  [key in EffectPropertyKey<T>]?: EffectConfig;\n};\n","import { Observable } from 'rxjs';\nimport { Action, ActionCreator } from '@ngrx/store';\nimport {\n  EffectMetadata,\n  EffectConfig,\n  DEFAULT_EFFECT_CONFIG,\n  CreateEffectMetadata,\n  CREATE_EFFECT_METADATA_KEY,\n} from './models';\n\ntype DispatchType<T> = T extends { dispatch: infer U } ? U : true;\ntype ObservableType<T, OriginalType> = T extends false ? OriginalType : Action;\ntype EffectResult<OT> = Observable<OT> | ((...args: any[]) => Observable<OT>);\ntype ConditionallyDisallowActionCreator<DT, Result> = DT extends false\n  ? unknown // If DT (DispatchType is false, then we don't enforce any return types)\n  : Result extends EffectResult<infer OT>\n  ? OT extends ActionCreator\n    ? 'ActionCreator cannot be dispatched. Did you forget to call the action creator function?'\n    : unknown\n  : unknown;\n\n/**\n * @description\n * Creates an effect from an `Observable` and an `EffectConfig`.\n *\n * @param source A function which returns an `Observable`.\n * @param config A `Partial<EffectConfig>` to configure the effect.  By default, `dispatch` is true and `useEffectsErrorHandler` is true.\n * @returns If `EffectConfig`#`dispatch` is true, returns `Observable<Action>`.  Else, returns `Observable<unknown>`.\n *\n * @usageNotes\n *\n * ** Mapping to a different action **\n * ```ts\n * effectName$ = createEffect(\n *   () => this.actions$.pipe(\n *     ofType(FeatureActions.actionOne),\n *     map(() => FeatureActions.actionTwo())\n *   )\n * );\n * ```\n *\n *  ** Non-dispatching effects **\n * ```ts\n * effectName$ = createEffect(\n *   () => this.actions$.pipe(\n *     ofType(FeatureActions.actionOne),\n *     tap(() => console.log('Action One Dispatched'))\n *   ),\n *   { dispatch: false }\n *   // FeatureActions.actionOne is not dispatched\n * );\n * ```\n */\nexport function createEffect<\n  C extends EffectConfig,\n  DT extends DispatchType<C>,\n  OT extends ObservableType<DT, OT>,\n  R extends EffectResult<OT>\n>(\n  source: () => R & ConditionallyDisallowActionCreator<DT, R>,\n  config?: Partial<C>\n): R & CreateEffectMetadata {\n  const effect = source();\n  const value: EffectConfig = {\n    ...DEFAULT_EFFECT_CONFIG,\n    ...config, // Overrides any defaults if values are provided\n  };\n  Object.defineProperty(effect, CREATE_EFFECT_METADATA_KEY, {\n    value,\n  });\n  return effect as typeof effect & CreateEffectMetadata;\n}\n\nexport function getCreateEffectMetadata<\n  T extends { [props in keyof T]: Object }\n>(instance: T): EffectMetadata<T>[] {\n  const propertyNames = Object.getOwnPropertyNames(instance) as Array<keyof T>;\n\n  const metadata: EffectMetadata<T>[] = propertyNames\n    .filter(\n      (propertyName) =>\n        instance[propertyName] &&\n        instance[propertyName].hasOwnProperty(CREATE_EFFECT_METADATA_KEY)\n    )\n    .map((propertyName) => {\n      const metaData = (instance[propertyName] as any)[\n        CREATE_EFFECT_METADATA_KEY\n      ];\n      return {\n        propertyName,\n        ...metaData,\n      };\n    });\n\n  return metadata;\n}\n","export function getSourceForInstance<T>(instance: T): T {\n  return Object.getPrototypeOf(instance);\n}\n","import { compose } from '@ngrx/store';\n\nimport {\n  DEFAULT_EFFECT_CONFIG,\n  EffectConfig,\n  EffectMetadata,\n  EffectPropertyKey,\n} from './models';\nimport { getSourceForInstance } from './utils';\n\nconst METADATA_KEY = '__@ngrx/effects__';\n\nexport function Effect(config: EffectConfig = {}) {\n  return function <T extends Object, K extends EffectPropertyKey<T>>(\n    target: T,\n    propertyName: K\n  ) {\n    const metadata: EffectMetadata<T> = {\n      ...DEFAULT_EFFECT_CONFIG,\n      ...config, // Overrides any defaults if values are provided\n      propertyName,\n    };\n    addEffectMetadataEntry<T>(target, metadata);\n  };\n}\n\nexport function getEffectDecoratorMetadata<T>(\n  instance: T\n): EffectMetadata<T>[] {\n  const effectsDecorators: EffectMetadata<T>[] = compose(\n    getEffectMetadataEntries,\n    getSourceForInstance\n  )(instance);\n\n  return effectsDecorators;\n}\n\n/**\n * Type guard to detemine whether METADATA_KEY is already present on the Class\n * constructor\n */\nfunction hasMetadataEntries<T extends Object>(\n  sourceProto: T\n): sourceProto is typeof sourceProto & {\n  constructor: typeof sourceProto.constructor & {\n    [METADATA_KEY]: EffectMetadata<T>[];\n  };\n} {\n  return sourceProto.constructor.hasOwnProperty(METADATA_KEY);\n}\n\n/** Add Effect Metadata to the Effect Class constructor under specific key */\nfunction addEffectMetadataEntry<T extends object>(\n  sourceProto: T,\n  metadata: EffectMetadata<T>\n) {\n  if (hasMetadataEntries(sourceProto)) {\n    sourceProto.constructor[METADATA_KEY].push(metadata);\n  } else {\n    Object.defineProperty(sourceProto.constructor, METADATA_KEY, {\n      value: [metadata],\n    });\n  }\n}\n\nfunction getEffectMetadataEntries<T extends object>(\n  sourceProto: T\n): EffectMetadata<T>[] {\n  return hasMetadataEntries(sourceProto)\n    ? sourceProto.constructor[METADATA_KEY]\n    : [];\n}\n","import { EffectMetadata, EffectsMetadata } from './models';\nimport { getCreateEffectMetadata } from './effect_creator';\nimport { getEffectDecoratorMetadata } from './effect_decorator';\n\nexport function getEffectsMetadata<T>(instance: T): EffectsMetadata<T> {\n  return getSourceMetadata(instance).reduce(\n    (\n      acc: EffectsMetadata<T>,\n      { propertyName, dispatch, useEffectsErrorHandler }\n    ) => {\n      acc[propertyName] = { dispatch, useEffectsErrorHandler };\n      return acc;\n    },\n    {}\n  );\n}\n\nexport function getSourceMetadata<T>(instance: T): EffectMetadata<T>[] {\n  const effects: Array<(instance: T) => EffectMetadata<T>[]> = [\n    getEffectDecoratorMetadata,\n    getCreateEffectMetadata,\n  ];\n\n  return effects.reduce<EffectMetadata<T>[]>(\n    (sources, source) => sources.concat(source(instance)),\n    []\n  );\n}\n","/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n});\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (p !== \"default\" && !exports.hasOwnProperty(p)) __createBinding(exports, m, p);\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nvar __setModuleDefault = Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, privateMap) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to get private field on non-instance\");\r\n    }\r\n    return privateMap.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, privateMap, value) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to set private field on non-instance\");\r\n    }\r\n    privateMap.set(receiver, value);\r\n    return value;\r\n}\r\n","import { Action } from '@ngrx/store';\nimport { merge, Notification, Observable } from 'rxjs';\nimport { ignoreElements, map, materialize } from 'rxjs/operators';\n\nimport { EffectNotification } from './effect_notification';\nimport { getSourceMetadata } from './effects_metadata';\nimport { EffectsErrorHandler } from './effects_error_handler';\nimport { getSourceForInstance } from './utils';\nimport { ErrorHandler } from '@angular/core';\n\nexport function mergeEffects(\n  sourceInstance: any,\n  globalErrorHandler: ErrorHandler,\n  effectsErrorHandler: EffectsErrorHandler\n): Observable<EffectNotification> {\n  const sourceName = getSourceForInstance(sourceInstance).constructor.name;\n\n  const observables$: Observable<any>[] = getSourceMetadata(sourceInstance).map(\n    ({\n      propertyName,\n      dispatch,\n      useEffectsErrorHandler,\n    }): Observable<EffectNotification> => {\n      const observable$: Observable<any> =\n        typeof sourceInstance[propertyName] === 'function'\n          ? sourceInstance[propertyName]()\n          : sourceInstance[propertyName];\n\n      const effectAction$ = useEffectsErrorHandler\n        ? effectsErrorHandler(observable$, globalErrorHandler)\n        : observable$;\n\n      if (dispatch === false) {\n        return effectAction$.pipe(ignoreElements());\n      }\n\n      const materialized$ = effectAction$.pipe(materialize());\n\n      return materialized$.pipe(\n        map(\n          (notification: Notification<Action>): EffectNotification => ({\n            effect: sourceInstance[propertyName],\n            notification,\n            propertyName,\n            sourceName,\n            sourceInstance,\n          })\n        )\n      );\n    }\n  );\n\n  return merge(...observables$);\n}\n","import { ErrorHandler } from '@angular/core';\nimport { Action } from '@ngrx/store';\nimport { Observable } from 'rxjs';\nimport { catchError } from 'rxjs/operators';\n\nexport type EffectsErrorHandler = <T extends Action>(\n  observable$: Observable<T>,\n  errorHandler: ErrorHandler\n) => Observable<T>;\n\nconst MAX_NUMBER_OF_RETRY_ATTEMPTS = 10;\n\nexport function defaultEffectsErrorHandler<T extends Action>(\n  observable$: Observable<T>,\n  errorHandler: ErrorHandler,\n  retryAttemptLeft: number = MAX_NUMBER_OF_RETRY_ATTEMPTS\n): Observable<T> {\n  return observable$.pipe(\n    catchError((error) => {\n      if (errorHandler) errorHandler.handleError(error);\n      if (retryAttemptLeft <= 1) {\n        return observable$; // last attempt\n      }\n      // Return observable that produces this particular effect\n      return defaultEffectsErrorHandler(\n        observable$,\n        errorHandler,\n        retryAttemptLeft - 1\n      );\n    })\n  );\n}\n","import { Inject, Injectable } from '@angular/core';\nimport {\n  Action,\n  ActionCreator,\n  Creator,\n  ScannedActionsSubject,\n} from '@ngrx/store';\nimport { Observable, OperatorFunction, Operator } from 'rxjs';\nimport { filter } from 'rxjs/operators';\n\n@Injectable()\nexport class Actions<V = Action> extends Observable<V> {\n  constructor(@Inject(ScannedActionsSubject) source?: Observable<V>) {\n    super();\n\n    if (source) {\n      this.source = source;\n    }\n  }\n\n  lift<R>(operator: Operator<V, R>): Observable<R> {\n    const observable = new Actions<R>();\n    observable.source = this;\n    observable.operator = operator;\n    return observable;\n  }\n}\n\n// Module-private helper type\ntype ActionExtractor<\n  T extends string | AC,\n  AC extends ActionCreator<string, Creator>,\n  E\n> = T extends string ? E : ReturnType<Extract<T, AC>>;\n/**\n * 'ofType' filters an Observable of Actions into an observable of the actions\n * whose type strings are passed to it.\n *\n * For example, if `actions` has type `Actions<AdditionAction|SubstractionAction>`, and\n * the type of the `Addition` action is `add`, then\n * `actions.pipe(ofType('add'))` returns an `Observable<AdditionAction>`.\n *\n * Properly typing this function is hard and requires some advanced TS tricks\n * below.\n *\n * Type narrowing automatically works, as long as your `actions` object\n * starts with a `Actions<SomeUnionOfActions>` instead of generic `Actions`.\n *\n * For backwards compatibility, when one passes a single type argument\n * `ofType<T>('something')` the result is an `Observable<T>`. Note, that `T`\n * completely overrides any possible inference from 'something'.\n *\n * Unfortunately, for unknown 'actions: Actions' these types will produce\n * 'Observable<never>'. In such cases one has to manually set the generic type\n * like `actions.ofType<AdditionAction>('add')`.\n */\nexport function ofType<\n  AC extends ActionCreator<string, Creator>[],\n  U extends Action = Action,\n  V = ReturnType<AC[number]>\n>(...allowedTypes: AC): OperatorFunction<U, V>;\n\nexport function ofType<\n  E extends Extract<U, { type: T1 }>,\n  AC extends ActionCreator<string, Creator>,\n  T1 extends string | AC,\n  U extends Action = Action,\n  V = T1 extends string ? E : ReturnType<Extract<T1, AC>>\n>(t1: T1): OperatorFunction<U, V>;\nexport function ofType<\n  E extends Extract<U, { type: T1 | T2 }>,\n  AC extends ActionCreator<string, Creator>,\n  T1 extends string | AC,\n  T2 extends string | AC,\n  U extends Action = Action,\n  V = ActionExtractor<T1 | T2, AC, E>\n>(t1: T1, t2: T2): OperatorFunction<U, V>;\nexport function ofType<\n  E extends Extract<U, { type: T1 | T2 | T3 }>,\n  AC extends ActionCreator<string, Creator>,\n  T1 extends string | AC,\n  T2 extends string | AC,\n  T3 extends string | AC,\n  U extends Action = Action,\n  V = ActionExtractor<T1 | T2 | T3, AC, E>\n>(t1: T1, t2: T2, t3: T3): OperatorFunction<U, V>;\nexport function ofType<\n  E extends Extract<U, { type: T1 | T2 | T3 | T4 }>,\n  AC extends ActionCreator<string, Creator>,\n  T1 extends string | AC,\n  T2 extends string | AC,\n  T3 extends string | AC,\n  T4 extends string | AC,\n  U extends Action = Action,\n  V = ActionExtractor<T1 | T2 | T3 | T4, AC, E>\n>(t1: T1, t2: T2, t3: T3, t4: T4): OperatorFunction<U, V>;\nexport function ofType<\n  E extends Extract<U, { type: T1 | T2 | T3 | T4 | T5 }>,\n  AC extends ActionCreator<string, Creator>,\n  T1 extends string | AC,\n  T2 extends string | AC,\n  T3 extends string | AC,\n  T4 extends string | AC,\n  T5 extends string | AC,\n  U extends Action = Action,\n  V = ActionExtractor<T1 | T2 | T3 | T4 | T5, AC, E>\n>(t1: T1, t2: T2, t3: T3, t4: T4, t5: T5): OperatorFunction<U, V>;\n/**\n * Fallback for more than 5 arguments.\n * There is no inference, so the return type is the same as the input -\n * Observable<Action>.\n *\n * We provide a type parameter, even though TS will not infer it from the\n * arguments, to preserve backwards compatibility with old versions of ngrx.\n */\nexport function ofType<V extends Action>(\n  ...allowedTypes: Array<string | ActionCreator<string, Creator>>\n): OperatorFunction<Action, V>;\nexport function ofType(\n  ...allowedTypes: Array<string | ActionCreator<string, Creator>>\n): OperatorFunction<Action, Action> {\n  return filter((action: Action) =>\n    allowedTypes.some((typeOrActionCreator) => {\n      if (typeof typeOrActionCreator === 'string') {\n        // Comparing the string to type\n        return typeOrActionCreator === action.type;\n      }\n\n      // We are filtering by ActionCreator\n      return typeOrActionCreator.type === action.type;\n    })\n  );\n}\n","import { ErrorHandler } from '@angular/core';\nimport { Action } from '@ngrx/store';\nimport { Notification, Observable } from 'rxjs';\n\nexport interface EffectNotification {\n  effect: Observable<any> | (() => Observable<any>);\n  propertyName: PropertyKey;\n  sourceName: string;\n  sourceInstance: any;\n  notification: Notification<Action | null | undefined>;\n}\n\nexport function reportInvalidActions(\n  output: EffectNotification,\n  reporter: ErrorHandler\n) {\n  if (output.notification.kind === 'N') {\n    const action = output.notification.value;\n    const isInvalidAction = !isAction(action);\n\n    if (isInvalidAction) {\n      reporter.handleError(\n        new Error(\n          `Effect ${getEffectName(\n            output\n          )} dispatched an invalid action: ${stringify(action)}`\n        )\n      );\n    }\n  }\n}\n\nfunction isAction(action: any): action is Action {\n  return (\n    typeof action !== 'function' &&\n    action &&\n    action.type &&\n    typeof action.type === 'string'\n  );\n}\n\nfunction getEffectName({\n  propertyName,\n  sourceInstance,\n  sourceName,\n}: EffectNotification) {\n  const isMethod = typeof sourceInstance[propertyName] === 'function';\n\n  return `\"${sourceName}.${String(propertyName)}${isMethod ? '()' : ''}\"`;\n}\n\nfunction stringify(action: Action | null | undefined) {\n  try {\n    return JSON.stringify(action);\n  } catch {\n    return action;\n  }\n}\n","import { Observable } from 'rxjs';\nimport { EffectNotification } from '.';\nimport { Action } from '@ngrx/store';\n\n/**\n * @description\n * Interface to set an identifier for effect instances.\n *\n * By default, each Effects class is registered\n * once regardless of how many times the Effect class\n * is loaded. By implementing this interface, you define\n * a unique identifier to register an Effects class instance\n * multiple times.\n *\n * @usageNotes\n *\n * ### Set an identifier for an Effects class\n *\n * ```ts\n * class EffectWithIdentifier implements OnIdentifyEffects {\n *  constructor(private effectIdentifier: string) {}\n *\n *  ngrxOnIdentifyEffects() {\n *    return this.effectIdentifier;\n *  }\n *\n * ```\n */\nexport declare interface OnIdentifyEffects {\n  /**\n   * @description\n   * String identifier to differentiate effect instances.\n   */\n  ngrxOnIdentifyEffects(): string;\n}\n\nexport const onIdentifyEffectsKey: keyof OnIdentifyEffects =\n  'ngrxOnIdentifyEffects';\n\nexport function isOnIdentifyEffects(\n  instance: any\n): instance is OnIdentifyEffects {\n  return isFunction(instance, onIdentifyEffectsKey);\n}\n\n/**\n * @description\n * Interface to control the lifecycle of effects.\n *\n * By default, effects are merged and subscribed to the store. Implement the OnRunEffects interface to control the lifecycle of the resolved effects.\n *\n * @usageNotes\n *\n * ### Implement the OnRunEffects interface on an Effects class\n *\n * ```ts\n * export class UserEffects implements OnRunEffects {\n *   constructor(private actions$: Actions) {}\n *\n *   ngrxOnRunEffects(resolvedEffects$: Observable<EffectNotification>) {\n *     return this.actions$.pipe(\n *       ofType('LOGGED_IN'),\n *       exhaustMap(() =>\n *         resolvedEffects$.pipe(\n *           takeUntil(this.actions$.pipe(ofType('LOGGED_OUT')))\n *         )\n *       )\n *     );\n *   }\n * }\n * ```\n */\nexport declare interface OnRunEffects {\n  /**\n   * @description\n   * Method to control the lifecycle of effects.\n   */\n  ngrxOnRunEffects(\n    resolvedEffects$: Observable<EffectNotification>\n  ): Observable<EffectNotification>;\n}\n\nexport const onRunEffectsKey: keyof OnRunEffects = 'ngrxOnRunEffects';\n\nexport function isOnRunEffects(instance: any): instance is OnRunEffects {\n  return isFunction(instance, onRunEffectsKey);\n}\n\n/**\n * @description\n * Interface to dispatch an action after effect registration.\n *\n * Implement this interface to dispatch a custom action after\n * the effect has been added. You can listen to this action\n * in the rest of the application to execute something after\n * the effect is registered.\n *\n * @usageNotes\n *\n * ### Set an identifier for an Effects class\n *\n * ```ts\n * class EffectWithInitAction implements OnInitEffects {\n *  ngrxOnInitEffects() {\n *    return { type: '[EffectWithInitAction] Init' };\n *  }\n * ```\n */\nexport declare interface OnInitEffects {\n  /**\n   * @description\n   * Action to be dispatched after the effect is registered.\n   */\n  ngrxOnInitEffects(): Action;\n}\n\nexport const onInitEffects: keyof OnInitEffects = 'ngrxOnInitEffects';\n\nexport function isOnInitEffects(instance: any): instance is OnInitEffects {\n  return isFunction(instance, onInitEffects);\n}\n\nfunction isFunction(instance: any, functionName: string) {\n  return (\n    instance &&\n    functionName in instance &&\n    typeof instance[functionName] === 'function'\n  );\n}\n","import { InjectionToken, Type } from '@angular/core';\nimport { EffectsErrorHandler } from './effects_error_handler';\n\nexport const _ROOT_EFFECTS_GUARD = new InjectionToken<void>(\n  '@ngrx/effects Internal Root Guard'\n);\nexport const IMMEDIATE_EFFECTS = new InjectionToken<any[]>(\n  'ngrx/effects: Immediate Effects'\n);\nexport const USER_PROVIDED_EFFECTS = new InjectionToken<Type<any>[][]>(\n  'ngrx/effects: User Provided Effects'\n);\nexport const _ROOT_EFFECTS = new InjectionToken<Type<any>[]>(\n  'ngrx/effects: Internal Root Effects'\n);\nexport const ROOT_EFFECTS = new InjectionToken<Type<any>[]>(\n  'ngrx/effects: Root Effects'\n);\nexport const _FEATURE_EFFECTS = new InjectionToken<Type<any>[]>(\n  'ngrx/effects: Internal Feature Effects'\n);\nexport const FEATURE_EFFECTS = new InjectionToken<any[][]>(\n  'ngrx/effects: Feature Effects'\n);\nexport const EFFECTS_ERROR_HANDLER = new InjectionToken<EffectsErrorHandler>(\n  'ngrx/effects: Effects Error Handler'\n);\n","import { ErrorHandler, Inject, Injectable } from '@angular/core';\nimport { Action } from '@ngrx/store';\nimport { Notification, Observable, Subject, merge } from 'rxjs';\nimport {\n  dematerialize,\n  exhaustMap,\n  filter,\n  groupBy,\n  map,\n  mergeMap,\n  take,\n} from 'rxjs/operators';\n\nimport {\n  reportInvalidActions,\n  EffectNotification,\n} from './effect_notification';\nimport { EffectsErrorHandler } from './effects_error_handler';\nimport { mergeEffects } from './effects_resolver';\nimport {\n  onIdentifyEffectsKey,\n  onRunEffectsKey,\n  OnRunEffects,\n  onInitEffects,\n  isOnIdentifyEffects,\n  isOnRunEffects,\n  isOnInitEffects,\n} from './lifecycle_hooks';\nimport { EFFECTS_ERROR_HANDLER } from './tokens';\nimport { getSourceForInstance } from './utils';\n\n@Injectable()\nexport class EffectSources extends Subject<any> {\n  constructor(\n    private errorHandler: ErrorHandler,\n    @Inject(EFFECTS_ERROR_HANDLER)\n    private effectsErrorHandler: EffectsErrorHandler\n  ) {\n    super();\n  }\n\n  addEffects(effectSourceInstance: any): void {\n    this.next(effectSourceInstance);\n  }\n\n  /**\n   * @internal\n   */\n  toActions(): Observable<Action> {\n    return this.pipe(\n      groupBy(getSourceForInstance),\n      mergeMap((source$) => {\n        return source$.pipe(groupBy(effectsInstance));\n      }),\n      mergeMap((source$) => {\n        const effect$ = source$.pipe(\n          exhaustMap((sourceInstance) => {\n            return resolveEffectSource(\n              this.errorHandler,\n              this.effectsErrorHandler\n            )(sourceInstance);\n          }),\n          map((output) => {\n            reportInvalidActions(output, this.errorHandler);\n            return output.notification;\n          }),\n          filter(\n            (notification): notification is Notification<Action> =>\n              notification.kind === 'N'\n          ),\n          dematerialize()\n        );\n\n        // start the stream with an INIT action\n        // do this only for the first Effect instance\n        const init$ = source$.pipe(\n          take(1),\n          filter(isOnInitEffects),\n          map((instance) => instance.ngrxOnInitEffects())\n        );\n\n        return merge(effect$, init$);\n      })\n    );\n  }\n}\n\nfunction effectsInstance(sourceInstance: any) {\n  if (isOnIdentifyEffects(sourceInstance)) {\n    return sourceInstance.ngrxOnIdentifyEffects();\n  }\n\n  return '';\n}\n\nfunction resolveEffectSource(\n  errorHandler: ErrorHandler,\n  effectsErrorHandler: EffectsErrorHandler\n): (sourceInstance: any) => Observable<EffectNotification> {\n  return (sourceInstance) => {\n    const mergedEffects$ = mergeEffects(\n      sourceInstance,\n      errorHandler,\n      effectsErrorHandler\n    );\n\n    if (isOnRunEffects(sourceInstance)) {\n      return sourceInstance.ngrxOnRunEffects(mergedEffects$);\n    }\n\n    return mergedEffects$;\n  };\n}\n","import { Injectable, OnDestroy } from '@angular/core';\nimport { Store } from '@ngrx/store';\nimport { Subscription } from 'rxjs';\n\nimport { EffectSources } from './effect_sources';\n\n@Injectable()\nexport class EffectsRunner implements OnDestroy {\n  private effectsSubscription: Subscription | null = null;\n\n  constructor(\n    private effectSources: EffectSources,\n    private store: Store<any>\n  ) {}\n\n  start() {\n    if (!this.effectsSubscription) {\n      this.effectsSubscription = this.effectSources\n        .toActions()\n        .subscribe(this.store);\n    }\n  }\n\n  ngOnDestroy() {\n    if (this.effectsSubscription) {\n      this.effectsSubscription.unsubscribe();\n      this.effectsSubscription = null;\n    }\n  }\n}\n","import { NgModule, Inject, Optional } from '@angular/core';\nimport {\n  createAction,\n  StoreModule,\n  Store,\n  StoreRootModule,\n  StoreFeatureModule,\n} from '@ngrx/store';\nimport { EffectsRunner } from './effects_runner';\nimport { EffectSources } from './effect_sources';\nimport { ROOT_EFFECTS, _ROOT_EFFECTS_GUARD } from './tokens';\n\nexport const ROOT_EFFECTS_INIT = '@ngrx/effects/init';\nexport const rootEffectsInit = createAction(ROOT_EFFECTS_INIT);\n\n@NgModule({})\nexport class EffectsRootModule {\n  constructor(\n    private sources: EffectSources,\n    runner: EffectsRunner,\n    store: Store<any>,\n    @Inject(ROOT_EFFECTS) rootEffects: any[],\n    @Optional() storeRootModule: StoreRootModule,\n    @Optional() storeFeatureModule: StoreFeatureModule,\n    @Optional()\n    @Inject(_ROOT_EFFECTS_GUARD)\n    guard: any\n  ) {\n    runner.start();\n\n    rootEffects.forEach((effectSourceInstance) =>\n      sources.addEffects(effectSourceInstance)\n    );\n\n    store.dispatch({ type: ROOT_EFFECTS_INIT });\n  }\n\n  addEffects(effectSourceInstance: any) {\n    this.sources.addEffects(effectSourceInstance);\n  }\n}\n","import { NgModule, Inject, Optional } from '@angular/core';\nimport { StoreRootModule, StoreFeatureModule } from '@ngrx/store';\nimport { EffectsRootModule } from './effects_root_module';\nimport { FEATURE_EFFECTS } from './tokens';\n\n@NgModule({})\nexport class EffectsFeatureModule {\n  constructor(\n    root: EffectsRootModule,\n    @Inject(FEATURE_EFFECTS) effectSourceGroups: any[][],\n    @Optional() storeRootModule: StoreRootModule,\n    @Optional() storeFeatureModule: StoreFeatureModule\n  ) {\n    effectSourceGroups.forEach((group) =>\n      group.forEach((effectSourceInstance) =>\n        root.addEffects(effectSourceInstance)\n      )\n    );\n  }\n}\n","import {\n  Injector,\n  ModuleWithProviders,\n  NgModule,\n  Optional,\n  Self,\n  SkipSelf,\n  Type,\n} from '@angular/core';\nimport { Actions } from './actions';\nimport { EffectSources } from './effect_sources';\nimport { EffectsFeatureModule } from './effects_feature_module';\nimport { defaultEffectsErrorHandler } from './effects_error_handler';\nimport { EffectsRootModule } from './effects_root_module';\nimport { EffectsRunner } from './effects_runner';\nimport {\n  _FEATURE_EFFECTS,\n  _ROOT_EFFECTS,\n  _ROOT_EFFECTS_GUARD,\n  EFFECTS_ERROR_HANDLER,\n  FEATURE_EFFECTS,\n  ROOT_EFFECTS,\n  USER_PROVIDED_EFFECTS,\n} from './tokens';\n\n@NgModule({})\nexport class EffectsModule {\n  static forFeature(\n    featureEffects: Type<any>[] = []\n  ): ModuleWithProviders<EffectsFeatureModule> {\n    return {\n      ngModule: EffectsFeatureModule,\n      providers: [\n        featureEffects,\n        {\n          provide: _FEATURE_EFFECTS,\n          multi: true,\n          useValue: featureEffects,\n        },\n        {\n          provide: USER_PROVIDED_EFFECTS,\n          multi: true,\n          useValue: [],\n        },\n        {\n          provide: FEATURE_EFFECTS,\n          multi: true,\n          useFactory: createEffects,\n          deps: [Injector, _FEATURE_EFFECTS, USER_PROVIDED_EFFECTS],\n        },\n      ],\n    };\n  }\n\n  static forRoot(\n    rootEffects: Type<any>[] = []\n  ): ModuleWithProviders<EffectsRootModule> {\n    return {\n      ngModule: EffectsRootModule,\n      providers: [\n        {\n          provide: EFFECTS_ERROR_HANDLER,\n          useValue: defaultEffectsErrorHandler,\n        },\n        EffectsRunner,\n        EffectSources,\n        Actions,\n        rootEffects,\n        {\n          provide: _ROOT_EFFECTS,\n          useValue: [rootEffects],\n        },\n        {\n          provide: _ROOT_EFFECTS_GUARD,\n          useFactory: _provideForRootGuard,\n          deps: [\n            [EffectsRunner, new Optional(), new SkipSelf()],\n            [_ROOT_EFFECTS, new Self()],\n          ],\n        },\n        {\n          provide: USER_PROVIDED_EFFECTS,\n          multi: true,\n          useValue: [],\n        },\n        {\n          provide: ROOT_EFFECTS,\n          useFactory: createEffects,\n          deps: [Injector, _ROOT_EFFECTS, USER_PROVIDED_EFFECTS],\n        },\n      ],\n    };\n  }\n}\n\nexport function createEffects(\n  injector: Injector,\n  effectGroups: Type<any>[][],\n  userProvidedEffectGroups: Type<any>[][]\n): any[] {\n  const mergedEffects: Type<any>[] = [];\n\n  for (let effectGroup of effectGroups) {\n    mergedEffects.push(...effectGroup);\n  }\n\n  for (let userProvidedEffectGroup of userProvidedEffectGroups) {\n    mergedEffects.push(...userProvidedEffectGroup);\n  }\n\n  return createEffectInstances(injector, mergedEffects);\n}\n\nexport function createEffectInstances(\n  injector: Injector,\n  effects: Type<any>[]\n): any[] {\n  return effects.map((effect) => injector.get(effect));\n}\n\nexport function _provideForRootGuard(\n  runner: EffectsRunner,\n  rootEffects: any[][]\n): any {\n  // check whether any effects are actually passed\n  const hasEffects = !(rootEffects.length === 1 && rootEffects[0].length === 0);\n  if (hasEffects && runner) {\n    throw new TypeError(\n      `EffectsModule.forRoot() called twice. Feature modules should use EffectsModule.forFeature() instead.`\n    );\n  }\n  return 'guarded';\n}\n","import { Action } from '@ngrx/store';\nimport {\n  defer,\n  merge,\n  Notification,\n  Observable,\n  OperatorFunction,\n  Subject,\n} from 'rxjs';\nimport {\n  concatMap,\n  dematerialize,\n  filter,\n  finalize,\n  map,\n  materialize,\n} from 'rxjs/operators';\n\n/** Represents config with named paratemeters for act */\nexport interface ActConfig<\n  Input,\n  OutputAction extends Action,\n  ErrorAction extends Action,\n  CompleteAction extends Action,\n  UnsubscribeAction extends Action\n> {\n  // Project function that produces the output actions in success cases\n  project: (input: Input, index: number) => Observable<OutputAction>;\n  // Error handle function for project\n  // error that happened during project execution\n  // input value that project errored with\n  error: (error: any, input: Input) => ErrorAction;\n  // Optional complete action provider\n  // count is the number of actions project emitted before completion\n  // input value that project completed with\n  complete?: (count: number, input: Input) => CompleteAction;\n  // Optional flattening operator\n  operator?: <Input, OutputAction>(\n    project: (input: Input, index: number) => Observable<OutputAction>\n  ) => OperatorFunction<Input, OutputAction>;\n  // Optional unsubscribe action provider\n  // count is the number of actions project emitted before unsubscribing\n  // input value that was unsubscribed from\n  unsubscribe?: (count: number, input: Input) => UnsubscribeAction;\n}\n\n/**\n * Wraps project fn with error handling making it safe to use in Effects.\n * Takes either config with named properties that represent different possible\n * callbacks or project/error callbacks that are required.\n */\nexport function act<\n  Input,\n  OutputAction extends Action,\n  ErrorAction extends Action\n>(\n  project: (input: Input, index: number) => Observable<OutputAction>,\n  error: (error: any, input: Input) => ErrorAction\n): (source: Observable<Input>) => Observable<OutputAction | ErrorAction>;\nexport function act<\n  Input,\n  OutputAction extends Action,\n  ErrorAction extends Action,\n  CompleteAction extends Action = never,\n  UnsubscribeAction extends Action = never\n>(\n  config: ActConfig<\n    Input,\n    OutputAction,\n    ErrorAction,\n    CompleteAction,\n    UnsubscribeAction\n  >\n): (\n  source: Observable<Input>\n) => Observable<\n  OutputAction | ErrorAction | CompleteAction | UnsubscribeAction\n>;\nexport function act<\n  Input,\n  OutputAction extends Action,\n  ErrorAction extends Action,\n  CompleteAction extends Action = never,\n  UnsubscribeAction extends Action = never\n>(\n  /** Allow to take either config object or project/error functions */\n  configOrProject:\n    | ActConfig<\n        Input,\n        OutputAction,\n        ErrorAction,\n        CompleteAction,\n        UnsubscribeAction\n      >\n    | ((input: Input, index: number) => Observable<OutputAction>),\n  errorFn?: (error: any, input: Input) => ErrorAction\n): (\n  source: Observable<Input>\n) => Observable<\n  OutputAction | ErrorAction | CompleteAction | UnsubscribeAction\n> {\n  const { project, error, complete, operator, unsubscribe } =\n    typeof configOrProject === 'function'\n      ? {\n          project: configOrProject,\n          error: errorFn!,\n          operator: concatMap,\n          complete: undefined,\n          unsubscribe: undefined,\n        }\n      : { ...configOrProject, operator: configOrProject.operator || concatMap };\n\n  type ResultAction =\n    | OutputAction\n    | ErrorAction\n    | CompleteAction\n    | UnsubscribeAction;\n  return (source) =>\n    defer(\n      (): Observable<ResultAction> => {\n        const subject = new Subject<UnsubscribeAction>();\n        return merge(\n          source.pipe(\n            operator((input, index) =>\n              defer(() => {\n                let completed = false;\n                let errored = false;\n                let projectedCount = 0;\n                return project(input, index).pipe(\n                  materialize(),\n                  map((notification):\n                    | Notification<ResultAction>\n                    | undefined => {\n                    switch (notification.kind) {\n                      case 'E':\n                        errored = true;\n                        return new Notification(\n                          // TODO: remove any in RxJS 6.5\n                          'N' as any,\n                          error(notification.error, input)\n                        );\n                      case 'C':\n                        completed = true;\n                        return complete\n                          ? new Notification(\n                              // TODO: remove any in RxJS 6.5\n                              'N' as any,\n                              complete(projectedCount, input)\n                            )\n                          : undefined;\n                      default:\n                        ++projectedCount;\n                        return notification;\n                    }\n                  }),\n                  filter((n): n is NonNullable<typeof n> => n != null),\n                  dematerialize(),\n                  finalize(() => {\n                    if (!completed && !errored && unsubscribe) {\n                      subject.next(unsubscribe(projectedCount, input));\n                    }\n                  })\n                );\n              })\n            )\n          ),\n          subject\n        );\n      }\n    );\n}\n"]}